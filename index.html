<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mini Sudoku</title>
    <style>
        :root {
            --border-color: #333;
            --cell-size: 15vw; 
            --error-color: #ffcccc;
            --text-error: #d93025;
            --selected-bg: #e8f0fe;
        }

        @media (min-width: 500px) {
            :root { --cell-size: 60px; }
        }

        body { 
            font-family: 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background: #f8f9fa; 
            margin: 0; 
            padding: 10px;
            touch-action: manipulation;
        }

        .stats-container { margin: 10px 0; font-weight: bold; }

        .controls { margin-bottom: 15px; display: flex; gap: 10px; }
        select, button { padding: 8px; font-size: 14px; border-radius: 5px; }

        .grid {
            display: grid;
            grid-template-columns: repeat(6, var(--cell-size));
            grid-template-rows: repeat(6, var(--cell-size));
            border: 2px solid var(--border-color);
            background-color: var(--border-color);
            gap: 1px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(var(--cell-size) * 0.5);
            cursor: pointer;
        }

        .cell:nth-child(3n) { border-right: 2px solid var(--border-color); }
        .cell:nth-child(6n) { border-right: none; }
        
        .grid > div:nth-child(n+13):nth-child(-n+18),
        .grid > div:nth-child(n+25):nth-child(-n+30) { border-bottom: 2px solid var(--border-color); }

        .cell.fixed { font-weight: bold; background-color: #eee; }
        .cell.error { background-color: var(--error-color); color: var(--text-error); }
        .cell.selected { background-color: var(--selected-bg); outline: 2px solid #007bff; z-index: 5; }

        .numpad {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: calc(var(--cell-size) * 6);
        }

        .num-btn {
            padding: 15px 0;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            font-size: 20px;
        }
        .num-btn:active { background: #e0e0e0; }
    </style>
</head>
<body>

    <div class="stats-container" id="timer">Time: 00:00</div>

    <div class="controls">
        <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
        <button onclick="startNewGame()" style="background:#007bff; color:white; border:none;">New Game</button>
    </div>

    <div class="grid" id="grid"></div>

    <div class="numpad">
        <div class="num-btn" onclick="inputValue(1)">1</div>
        <div class="num-btn" onclick="inputValue(2)">2</div>
        <div class="num-btn" onclick="inputValue(3)">3</div>
        <div class="num-btn" onclick="inputValue(4)">4</div>
        <div class="num-btn" onclick="inputValue(5)">5</div>
        <div class="num-btn" onclick="inputValue(6)">6</div>
        <div class="num-btn" onclick="inputValue(0)" style="background: #ffdada; grid-column: span 3;">Clear</div>
    </div>

    <script>
        const gridElement = document.getElementById('grid');
        const timerElement = document.getElementById('timer');
        let selectedCell = null;
        let solution = [];
        let initialBoard = [];
        let currentBoard = []; // Track user's current progress
        let timerInterval = null;
        let seconds = 0;

        function updateTimerDisplay() {
            let m = Math.floor(seconds/60).toString().padStart(2,'0');
            let s = (seconds%60).toString().padStart(2,'0');
            timerElement.innerText = `Time: ${m}:${s}`;
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                seconds++;
                updateTimerDisplay();
                saveGame(); // Save time every second
            }, 1000);
        }

        function saveGame() {
            const gameState = {
                solution,
                initialBoard,
                currentBoard,
                seconds,
                difficulty: document.getElementById('difficulty').value
            };
            localStorage.setItem('sudoku_save', JSON.stringify(gameState));
        }

        function loadGame() {
            const saved = localStorage.getItem('sudoku_save');
            if (saved) {
                const data = JSON.parse(saved);
                solution = data.solution;
                initialBoard = data.initialBoard;
                currentBoard = data.currentBoard;
                seconds = data.seconds;
                document.getElementById('difficulty').value = data.difficulty;
                
                render();
                updateTimerDisplay();
                startTimer();
                return true;
            }
            return false;
        }

        function generateSudoku() {
            let board = Array(6).fill().map(() => Array(6).fill(0));
            const isValid = (b, r, c, n) => {
                for (let i = 0; i < 6; i++) if (b[r][i] === n || b[i][c] === n) return false;
                let sr = Math.floor(r/2)*2, sc = Math.floor(c/3)*3;
                for (let i=0; i<2; i++) for (let j=0; j<3; j++) if (b[sr+i][sc+j] === n) return false;
                return true;
            };
            const solve = (b) => {
                for (let r=0; r<6; r++) for (let c=0; c<6; c++) {
                    if (b[r][c] === 0) {
                        let nums = [1,2,3,4,5,6].sort(()=>Math.random()-0.5);
                        for (let n of nums) if (isValid(b,r,c,n)) {
                            b[r][c] = n; if (solve(b)) return true; b[r][c] = 0;
                        }
                        return false;
                    }
                }
                return true;
            };
            solve(board);
            solution = board.map(row => [...row]);
        }

        function startNewGame() {
            localStorage.removeItem('sudoku_save'); // Clear previous save
            const diff = document.getElementById('difficulty').value;
            const blanks = { 'easy': 12, 'medium': 18, 'hard': 22 }[diff];
            generateSudoku();
            
            initialBoard = solution.map(row => [...row]);
            let count = 0;
            while (count < blanks) {
                let r = Math.floor(Math.random()*6), c = Math.floor(Math.random()*6);
                if (initialBoard[r][c] !== 0) { initialBoard[r][c] = 0; count++; }
            }
            
            // Initialize currentBoard as a copy of initialBoard
            currentBoard = initialBoard.map(row => [...row]);
            seconds = 0;
            render();
            startTimer();
            saveGame();
        }

        function render() {
            gridElement.innerHTML = '';
            for (let r=0; r<6; r++) for (let c=0; c<6; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r; 
                cell.dataset.c = c;

                if (initialBoard[r][c] !== 0) {
                    cell.innerText = initialBoard[r][c];
                    cell.classList.add('fixed');
                } else {
                    // Load user input if it exists
                    if (currentBoard[r][c] !== 0) {
                        cell.innerText = currentBoard[r][c];
                        if (currentBoard[r][c] !== solution[r][c]) cell.classList.add('error');
                    }
                    
                    cell.onclick = () => {
                        if (selectedCell) selectedCell.classList.remove('selected');
                        selectedCell = cell;
                        cell.classList.add('selected');
                    };
                }
                gridElement.appendChild(cell);
            }
        }

        function inputValue(n) {
            if (!selectedCell) return;
            const r = parseInt(selectedCell.dataset.r);
            const c = parseInt(selectedCell.dataset.c);
            
            if (n === 0) { 
                selectedCell.innerText = ''; 
                selectedCell.classList.remove('error'); 
                currentBoard[r][c] = 0;
            } else {
                selectedCell.innerText = n;
                currentBoard[r][c] = n;
                if (n != solution[r][c]) selectedCell.classList.add('error');
                else selectedCell.classList.remove('error');
            }

            saveGame();

            // Check Win Condition
            const cells = [...document.querySelectorAll('.cell')];
            if (cells.every(el => el.innerText != '' && !el.classList.contains('error'))) {
                clearInterval(timerInterval);
                localStorage.removeItem('sudoku_save');
                alert("Winner!");
            }
        }

        // Initialize: Load saved game or start new one
        if (!loadGame()) {
            startNewGame();
        }
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW active'))
                    .catch(err => console.log('SW failed', err));
            });
        }
    </script>
</body>
</html>
